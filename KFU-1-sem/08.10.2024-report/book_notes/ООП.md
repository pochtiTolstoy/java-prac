Источник - Шилдт полное руководство по Java 12 издание
Стр: 162 - 245
# Глава 6. Введение в классы
* Данные, или переменные, опрееделенные в классе, называются переменными экземпляра. 
* В совокупности методы и переменные, определенные в классе, называются членами класса.
* Именно методы определяют как можно использовать данные класса.
* Каждый экземпляр класса содержит собсвтенную копию этих переменных
* `main()` - указывается только в том случае, если класс является начальной точкой для выполнения программы. Некоторые приложения на java вообще не требуют метода `main`
## Простой класс
```java
class Box {
  double width;
  double height;
  double length;
}
```
* Новый тип данных - `Box`
* Это создание только шаблона, а не самого конкретного объекта.
* Чтобы создать настоящий объект нужно написать:
```java
Box mybox = new Box();
```
* После выполнения `mybox` будет ссылаться на экземпляр `Box`.
```java
mybox.width = 100;
```
* Вся программа:
```java
class Box {
  double width;
  double height;
  double depth;
}

class BoxDemo {
  public static void main(String[] args) {
    Box myBox = new Box; 
    double val;
    myBox.width = 10;
    myBox.height = 20;
    myBox.depth = 15;
    val = mybox.width * myBox.height * myBox.depth;
    System.out.println("Volume of Box: " + val);
  }
}
```
* Классы Box и BoxDemo не обязательно должны находиться в одном и том же исходном файле. Можно поместить классы в собственные файлы с именами Box.java и DemoBox.java
## Объявление объектов
* `new` - создает физическую копию объекта и присваивает ее переменной ссылочного типа. По существу это просто адрес памяти объекта, выделенный `new`.
* Все объекты класса должны размещаться динмаически.
* Если явный ктр не указан, то Java автоматически предоставит стандартный конструктор, что и происходит в случае Box
* `new` - может бросить исключение, если не нашли нужное кол-во памяти.
## Введение в методы
```java
class Box {
  double width;
  double height;
  double depth;
  void volume() {
    System.out.print("Volume: "); 
    System.out.println(width * height * depth);
  }
}

// main...
Box b1 = new Box();
Box b2 = new Box();
// init...
b1.volume();
b2.volume();
```
* Когда доступ к переменной экземпляра осуществляется кодом, который не входит в состав класса, где определена данная переменная экземпляра, то его придется делать через объект с использованием операции точки. Тем не менее, когда к переменной экземпляра обращается код, который входит в состав того же класса, что и переменная экземпляра, то на переменную можно ссылаться напрямую. То же самое относится и к методам.
##  Метод с параметрами
```java
class Box {
  //...
  double volume() { return width * heigth * depth; }
  void setDim(double w, double h, double d) {
    width = w;
    height = h;
    depth = d; 
  }
}
//in main, usage:
mybox1.setDim(10, 20, 14);
```
## КТРы
* ктр иниц объект сразу после создания. Неявным возвращаемым типов ктра является сам класс.
```java
class Box {
  double width;
  double height;
  double depth;
  Box() {
    System.out.println("Create box"); 
    width = 10;
    height = 10;
    depth = 10; 
  }
  //...
}
```
* Если ктр не указан, то тогда java создаст дефолтный ктр
* По дефолту все проставляется нулями и null.
* Для более сложных классов нужно писать свой ктр

## Параметризованные ктры
```java
class Box {
//....
  Box(double w, double h, double d) {
    width = w;
    height = h;
    depth = d; 
  }
}
//usage:
Box b = new Box(10, 12, 123);
```
## Ключевое слово this
* Его можно использовать внутри любого метода для ссылки на текущий объект.
```java
Box(double w, double h, double d) {
  this.width = w;
  this.height = h;
  this.depth = d;
}
```
## Сокрытие переменных экземпляра
```java
Box(double width, double height, double depth) {
  this.width = width;
  this.height = height;
  this.depth = depth;
}
```
## Сборка мусора
* Garbage collector...
* Сборка мусора происходит нерегулярно во время выполнения
* Если ссылок на объект не существует, значит нужно 

# Глава 7. подробный анализ методов и классов
## Перегрузка методов
* Перегрузка - один из видов полиморфизма в java
* Java смотрит на тип и кол-во параметров метода.
* По возвращаемому типу методы не перегружаются!
```java
class OverloadDemo {
  int test() { return 0; }
  int test(int a) { return a; }
  int test(int a, int b) { return a + b; }
  double test(double a) { return a * a; }
}
```
* Совпадение аргументов не всегда должно быть точным. Автоматическое преобразование может неявно произойти и пройти по одной ветке перегрузки.
* Если `test(int)` будет не определен то тогда `test(10)` будет неявно приводиться в double, и будет вызван метод `test(double)`.
* Полиморфизм, потому что это один из спопосбов, которым в java реализуется парадигма "один интерфейс, несколько методов". В языках без перегрузки, нужно писать уникальные имена для функций, которые по сути могут делать одно и то же.
* Выбор правильной версии возлагается на компилятор.
## Перегрузка ктров
```java
class Box {
  //...
  Box(double w, double h, double d) {
    //... 
  }
}
```
* После определения ктра, дефолтный уже не генерируется компилятором.
```java
class Box {
//...
  Box(double w, double h, double d) { /*...*/ }
  Box() { /*...*/ }
  Box(double len) { /*...*/ }
  //...
}
```
* На основе аргументов, указанных при выполнении `new`, вызываться надлежащий перегруженный ктр
## Использование объектов в качестве параметров
* Объекты можно передавать в методы.
```java
class Test {
  int a, b;
  Test(int i, int j) {
    a = i; 
    b = j;
  }
  boolean equalTo(Test o) { return o.a == a && o.b == b; }
}
//usage:
ob1.equalTo(ob2); // -> true, false
```
* Один объект иниц другой:
```java
class Box {
//...
  Box(Box ob) {
    width = ob.width;
    height = ob.height;
    depth = ob.depth;
  }
  Box(double w, double h, double d) {
  }
//...
}
//usage:
Box b1 = new Box(10, 20, 15);
Box b2 = new Box(b1); // clone
```

## Анализ передачи аргументов
* Вызов по значению, при котором в формальный параметр подпрограммы копируется значение аргумента, поэтому изменения, вносимые в параметр подпрограммы, не влияют на аргумент.
* Второй способ по ссылке. передается ссылка и изменения внутри метода действуют на реальный объект в памяти.
* В java для передачи всех аргументов используется вызов по значению, точный результат зависит от того, какой тип передается - примитивный или ссылочный.
* Примитив - по значению, копия
* Ссылочный - копии нет, работаем с объектом под ссылкой
```java
class Test {
  void meth(int i, int j) {
    i *= 2;
    j /= 2; 
  }
}

class CallByValue {
  public static void main(String[] args) {
    Test ob = new Test();
    int a = 15, b = 20;
    sout(a + " " + b);
    ob.meth(a, b);
    sout(a + " " + b);
  }
}
```
* Вызов метода не повлияет на значения, так как они примитивы и происходит копия при вызове метода.
* Если бы передавали объект, то изменения бы произошли
* Можно возвращать объекты, в вызывающей процедуре будет возвращаться ссылка на него. Не нужно беспокоиться, что объект выйдет за пределы области видимости, т.к. метод в котором он создан завершается. Объект существует, пока существует хотя бы одна ссылка на него.

## Управление доступом
* Инкапсуляция связывает данные с кодом, которой ими манипулирует.
* Также инкапсуляция предоставляет: управление доступом
* Можно контролировать то, какие части программы могут обращаться к членам класса.
* Доступ к членам класса определяется модификатором доступа, присоединенным к его объявлению
* Некоторые аспекты управления доступом в основном связаны с наследованием или пакетами (пакет по существу представляет собой группу классов).
* public, private, protected. Есть стандартный уровень доступа. Модификатор protected применяется только когда задействовано наследование.
* public - досутп может получить любой другой код.
* private - только другие члены класса
* Если модификатор доступа не задействован, то по умолчанию член класса является открытым в своем пакете, но к нему нельзя получить доступ за пределами пакета.
```java
class Stack {
  private int[] stck = new int[10];
  private int tos;
  Stack() {
    tos = -1; 
  }
  void push(int item) {
    if (tos == 9)  {
      sout("Stack is full"); 
    } else {
      stck[++tos] = item;
    }
  }
  int pop() {
    if (tos < 0) {
      sout("Stack is empty"); 
      return 0;
    } else {
      return stck[tos--];
    }
  }
}
```
## Ключевое слово static
* Член класса, который относится к самому классу, а не конкретному экземпляру этого класса.
* Можно объявлять как метода так и переменные
* Они могут напрямую вызывать только другие статические методы своего класса
* Они могут напрямую получать доступ только к статическим переменным своего класса
* Они никоим образом не могут ссылаться на this или super
* Блок кода тоже можно обернуть в static
```java
class UseStatic {
  static int a = 3;
  static int b;
  static void meth(int x) {
    sout(x);
    sout(a);
    sout(b);
  }
  static { // will be triggered automaticly
    sout("init in static block"); 
    b = a * 4;
  }
}
```
## Ключевое слово final
* Поле может быть объявлено как final, что предотвращает изменение его содержимого, делая его по существу константой.
* Объявление параметра как final предотвращает его изменение внутри метода.
* Объявление локальной переменной как final предотвращает присваивание ей значения более одного разаю
## Массивы
* Массивы реализованы в виде объектов. Есть переменная `length`. Есть оверхэд
```java
class Length {
  public static void main(String[] args) {
    int[] a1 = new int[10];
    int[] a2 = {3, 5, 5, 6, 7};
    int[] a3 = {5, 6, 7};
    sout(a1.length);
    sout(a2.length);
    sout(a3.length);
  }
}
```
## Вложенные и внутренние классы
* Вложенный класс имеет доступ к private членам внешнего класса
* Есть два типа вложенных классов: статические и нестатические
* статический вложенный класс не может напрямую ссылаться на нестатические члены объемлющего класса
* вторым типом вложенного класса является внутренний класс. Внутренний класс - это нестатический вложенный класс. Он имеет доступ ко всем переменным и методам всего внешнего класса и может ссылаться на них напрямую.
```java
class Outer {
  int outer_x = 100;
  void test() {
    Inner inner = new Inner(); 
    inner.display();
  }
  class Inner {
    void display() {
      sout("display(): outer_x = " + outer_x); // can access field of Outer
    } 
  }
}

class InnerClassDemo {
  public static void main(String[] args) {
    Outer outer = new Outer(); 
    outer.test();
  }
}
```
* Члены внутреннего класса известны только в рамках области действия внутреннего класса и не могут использоваться внешним классом.
* Вложенные классы полезны для обработки событий.
* Есть анонимные внутренние классы
## Исследование класса String
* Иммутабельность
* Если хотим изменить строку, то нужно создавать новую
* Есть классы `StringBuffer`, `StringBuilder`, которые позволяют изменять строки.
* Две строки сравниваются с помощью метода `equals`. По `charAt` можно достать символ по индексу
## Аргументы командной строки
```java
class CommandLine {
  public static void main(String[] args) {
    for (int i = 0; i != args.length; ++i) {
      sout("args[" + i + "]: " + args[i]); 
    }
  }
}
```
## Аргументы переменной длины
* (int... v)
```java
class A {
  static void vaTest(String msg, int ... v) {
    sout(msg);
    for (int x : v) {
      sout(x + " ");
    }
  }
}
```
## Перегрузка методов с аргументами переменной длины
```java
class A {
  static void vaTest(int ... v) {}
  static void vaTest(boolean ... v) {}
  static void vaTest(String msg, int ... v) {}
}
```
* Можно перегружать по отличающемуся типу
* Или добавить новые параметры слева от `...`
* Можно перегрузить одним интом
## Аргументы переменной длины и неоднозначность
```java
class A {
  static void vaTest(int ... v) {}
  static void vaTest(boolean ... v) {}
}
//...
vaTest(); // Неоднозначность
```

```java
class A {
  static void vaTest(int a, int ... v);
  static void vaTest(int ... v);
}
//...
vaTest(1); // ???
```
* Иногда приходится отказаться от перегрузки и использовать методы с разными именами.

## Выведение типов локальных переменных для ссылочных типов
```java
var myStr = "this is string";
```

```java
var fin = new FileInputStream("test.txt");
```

```java
class MyClass {
  private int i;
  MyClass(int k) { i = k; }
  int geti() { return i; }
  void seti(int k ) { if (k >= 0) i = k; }
}

class RefVarDemo {
  public static void main(String[] args) {
    var mc = new MyClass(10);
  }
}
```

# Глава 8. Наследование
* Унаследованный класс называется super классом
* А класс выполняющий наследование - подклассом
* Подкласс представляет собой специализированную версию суперкласса.
* Он наследует все члены, определенные суперклассом и добавляет собственные уникальные элементы
## Основы наследования
* extends
```java
class A {
  int i, j;
  void showij() {}
}
class B extends A {
  int k;
  void showk() {}
  void sum() {sout(i + j + k);}
}
```
* B включает в себя все члены и методы A
* Можно наследовать только один суперкласс
## Доступ к членам и наследование
* К закрытым членам суперкласса нет доступа
```java
class A {
  int i;
  private int j;
  void setij(int x, int y) {}
}
class B extends A {
  int total;
  void sum() { total = i + j; } // j недоступен
}
```
* j доступен только членам собственного класса. Подклассы не имеют к нему доступа
## Пример
```java
class Box {
  double width;
  double height;
  double depth;
  Box(Box ob) {
    width = ob.width;
    height = ob.height; 
    depth = ob.depth;
  }
  Box(double w, double h, double d) {
    width = w;
    height = h;
    depth = d; 
  }
  Box() {
    width = -1; 
    height = -1; 
    depth = -1; 
  }
  Box(double len) { width = hegith = depth = len; }
  double volume() { return width * height * depth; }
}

class BoxWeight extends Box {
  double weight;
  BoxWeight(double w, double h, double d, double m) { // Нужно делегирование
    width = w;
    height = h;
    depth = d;
    weidht = m; 
  }
}

class DemoBoxWeight {
  public static void main(String[] args) {
    BoxWeight b1 = new BoxWeight(10, 20, 15, 3.0);
  }
}
```
* Суперкласс можно наследовать для формирования специализированных классов. Каждый подкласс просто добавляет свои уникальные характеристики.
## Переменная типа суперкласса может ссылаться на объект подкласса
* Ссылочной переменной типа суперкласса можно присваивать ссылку на объект любого подкласса, производного от данного суперкласса.
* Тип ссылочной переменной, а не тип объекта, на который она ссылается, определяет к каким членам можно получать доступ. Через ссылку на базу мы получаем только видимость базового объекта, хотя в реальности под нами лежит дочерний объект.
## Использование super для ктров суперкласса
* `super(список-арг)`
* Список нужен, чтобы передать нужные аргументы в ктр суперкласса
```java
class BW : B {
  double weight;
  BW(double w, double h, double d, double m) {
    super(w, h, d);
    weight = m;
  }
}
```
* Для вызова super будет разрешена перегрузка между ктрами суперкласса
* В super можно также передавать и дочерний объект по ссылке на базу
```java
class B {
  double a, b, c;
  B(B obj) {
    a = obj.a; 
    b = obj.b; 
    c = obj.c; 
  }
//...
}
class BB extends B {
  double d;
  BB(BB obj) {
    super(obj); // will trigger B(B obj)
    d = obj.d;
  }
}
```
* Также можно вызывать ктр по умолчанию `super();`
* super ссылается на суперкласс над текущим классом
* super всегда должен быть первым опреатором, выполняемым внутри конструктора подкласса

## Использование второй формы super
* Используется при сокрытии имен при наследовании
```java
class A { int i; }
class B extends A {
  int i;
  B(int a, int b) {
    super.i = a; // также можно использовать для вызова сокрытого метода
    i = b; 
  }
}
```
## Создание многоуровневой иерархии
```java
class Box {
  private double width;
  private double height;
  private double depth;
  Box(Box ob) {
    width = ob.width; 
    heigth = ob.height; 
    depth = ob.depth; 
  }
  Box(double w, double h, double d) {
    width = w;
    height = h;
    depth = d; 
  }
  Box() { /* ... */ }
  /* ... */
}

class BW extends Box {
  double weight;
  BW(BW ob) {
    super(ob);
    weight = ob.weight;
  }
  /* ... */
}

class Shipment extends BW {
  double cost;
  Shipment(Shipment ob) {
    super(ob);
    cost = ob.cost;
  }
  /* ... */
}
```
* Наследование позволяет многократно использовать код
* super всегда ссылается на ктр в ближайшем суперклассе.
* Когда ктру суперкласса нужны аргументы, то все подклассы должны передавать их "вверх по цепочке наследования".
* При создании иерархий классов стоит разносить их в свои файлы

## Когда ктры выполняются
* Иниц сначала база, потом иниц дочерние подклассы
* Если super не используется, то будет вызван неявно `super();`
## Переопределение методов
* Если метод в подклассе имеет то же имя и ту же сигнатуру, то говорят, что метод в подклассе переопределяет метод в суперклассе. При вызове переопределенного метода через его подкласс всегда будет вызываться версия метода, определенная в подклассе. Версия определенная в суперклассе будет сокрыта.
* Метод переорпеделяется только в случае, если имена и сигнатуры типов двух методов ижентичны, а иначе два метода будут просто перегруженными. Метод из суперкласса не сокроется, и будет вызван, когда сработает разрешение перегрузки в пользу этого метода.
## Динамическая диспетчеризация методов
* вызов переопределенного метода будет распознаваться во время выполнения, а не на этапе компиляции. Так обеспечивается полиморфизм во время выполнения.
* Когда переопределенный метод вызывается через ссылку на суперкласс, версия метода, подлежащая выполнению, выясняется на основе типа объекта, на которой производится ссылка в момент вызова.
* При ссылке на разные типы объектов будут вызываться разные версии переопределенного метода. Именно тип объекта на который делается ссылка определяет какая версия переопределенного метода будет выполняться.
```java
class A {
  void callme() {sout("A");}
}
class B extends A {
  void callme() { sout("B"); }
}
class C extends A {
  void callme() { sout("B"); }
}
class Dispatch {
  public static void main(String[] args) {
    A a = new A(); 
    B b = new B();
    C c = new C();
    A r;
    r = a;
    r.callme(); // A
    r = b;
    r.callme(); // B
    r = c;
    r.callme(); // C
  }
}
```
* По ссылке на базу автоматически выбирается наиболее актуальное переопределение в зависимости от настоящего объекта, который лежит под ссылкой.

## Зачем нужны переопределенные методы?
* Полиморфизм нужен, чтобы универсальный класс определял методы, которые будут общими для всех производных классов. Одновременно разрешая подклассам поределять индивидуальные реализации некоторых или всех общих методов.
* Подкласс может гибко определять собственные методы, но также обеспечивать согласованный интерфейс
* Комбинируя наследование с переопределенными методами, суперкласс может определять общую форму методов, которые будут потребляться всеми его подклассами.
* Абстрактный интерфейс -> спецификации
## Применение переопределения методов
```java
class Figure {
  double dim1;
  double dim2;
  Figure(double a, double b) {
    dim1 = a;
    dim2 = b; 
  }
  double area() {
    sout("No definition for Figure class"); 
    return 0;
  }
}
class Rectangle extends Figure {
  Rectangle(double a, double b) {
    super(a, b);
  }
  double area() {
    return dim1 * dim2;
  }
}

class Triangle extends Figure {
  Triangle(double a, double b) { super(a, b); }
  double area() { return dim1 * dim2 / 2; }
}
```
* Теперь по базовой ссылке можно дергать разные методы в зависимости от того, что реально лежит под этой ссылкой.
* Интерфейс этой операции одинаков вне зависимости от того, какой тип фигуры используется.

## Использование абстрактных классов
* Иногда нужно создать суперкласс, который только объявляет методы, но не реализует их. Это происходит когда суперкласс не способен создать осмысленную реализацию метода.
* Нужна гарантия того, что наследники не забудут переопределить этот метод для себя
* Это решается с помощью абстрактных методов
* `abstract`
* Любой класс, содержащий один или несколько абстрактных методов тоже должен быть объявлен как абстрактный
* Объектов абстрактного класса не бывает, их нельзя создать.
* Нельзя объявлять абстрактные ктры или абстрактные статические методы
* Любой подкласс либо должен все реализовать, либо сам стать асбтрактным
```java
abstract class A { // создать A - невозможно
  abstract void callme();
  void callmetoo() {
    sout("callmettoo from A"); 
  }
}
class B extends A {
  void callme() {
    sout("implementation of callme in B class");
  }
}
class AbstractDemo {
  public static void main(String[] args) {
    B b = new B(); 
    b.callme();
    b.callmetoo();
  }
}
```
* Абстрактный класс допускает реализацию конкретного метода в себе
* Эти классы можно применять как базовые ссылки на объекты. То есть объект этого класса создать нельзя, а вот ссылку можно.
## Использование ключевого слова final с наследованием
* Применяется в трех ситуациях.
## Использование ключевого слова final  для предотвращения переопределения
* Методы объявленные как final не могут быть переопределены
```java
class A {
  final void meth() {
    sout("final method"); 
  }
}
class B extends A {
  void meth() {} // Ошибка!
}
```
* Компилятор способен делать inline методов final. Вызов final методов распознается в compile time, а не runtime, как остальные. Это возможно потому что мы гарантируем, что не будет переопределения метода final. Поэтому вызов этого метода решен еще на этапе компиляции, следовательно может быть соптимизирован.
## Использование ключевого слова final для предотвращения наследования
* Иногда нужно предотвратить наследование самого класса. Для этого перед объявлением класса дописывают final. Неявно объявляет все его методы как final.
* Объявлять класс как abstract и final не имеет смысла, потому что с одной стороны ты не можешь создать такой класс, а с другой стороны, ты не можешь от него наследоваться.
## Выведение типов локальных переменных и наследование
* При использования выведения локальной переменной с помощью ключевого слова `var` ее тип будет базироваться на объявленном типе ее инициализатора. var должно быть известно на этапе компиляции, а во время  компиляции нет динамического полиморфизма. Поэтому тип выводится как базовый класс, а не то что под ним лежит в рантайме
## Класс Object
* Все классы являются подклассами Object в Java. Object может ссылаться на массивы и любые классы
* В Object есть методы, которые доступны в любом объекте:
* `Object clone()` - создает новый объект, который совпадает с клонируемым объектом
* `boolean equals(Object)` - определяет равен ли один объект другому
* `void finalize()` - deprecated
* `Class<?> getClass()` - получает класс объекта во время выполнения
* `int hashCode()` - хэш
* `int notify()` - возобновляет выполнения потока, ожидающего вызывающий объект
* `void notifyAll()` - возобновляет выполнения всех потоков, ожидающих вызывающий объект
* `String toString()` - возвращает строку, которая описывает объект
* `void wait()` - ожидает другого потока выполнения
* Методы `getClass()`, `notify()`, `notifyAll()`, `wait()` объявлены как final. их нельзя переопределить.
* Остальные методы могут переопрделяться
* `equals` - совпадение объектов может меняться в зависимости семантики объекта.
* `println` - автоматически вызывает метод `toString` 
